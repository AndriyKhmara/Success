<!DOCTYPE html>
<html>
	<head> 
	    <meta charset="utf-8"/>
	    <link rel="stylesheet" href="../css/bookStyle.css"/>
		<title>Пророждающие паттерны</title>
	</head>
	<body>
		<a href="../index.html" >
		<div id="button">
				<p>HOME</p>
		</div>
		</a>		
			<div class="content">
				<h3>Паттерн Builder</h3>
				<p><b><i>Название и классификация паттерна</i></b></p>
				<p>Строитель - паттерн, порождающий объекты.</p>
				<p><b><i>Назначение</i></b></p>
				 <p>Отделяет конструирование сложного объекта от его представления, так что
				в результате одного и того же процесса конструирования могут получаться раз
				ные представления.</p>
				<p><b><i>Мотивация</p></b></i>
				 <p>Программа, в которую заложена возможность распознавания и чтения доку
				мента в формате RTF (Rich Text Format), должна также «уметь» преобразовывать
				его во многие другие форматы, например в простой ASCII-текст или в представ
				ление, которое можно отобразить в виджете для ввода текста. Однако число веро
				ятных преобразований заранее неизвестно. Поэтому должна быть обеспечена воз
				можность без труда добавлять новый конвертор.</p>
				 <p>Таким образом, нужно сконфигурировать класс RTFReader с помощью объек
				та Text Converter, который мог бы преобразовывать RTF в другой текстовый
				формат. При разборе документа в формате RTF класс RTFReader вызывает
				TextConverter для выполнения преобразования. Всякий раз, как RTFReader
				распознает лексему RTF (простой текст или управляющее слово), для ее преобра
				зования объекту TextConverter посылается запрос. Объекты TextConverter
				отвечают как за преобразование данных, так и за представление лексемы в кон
				кретном формате.</p>
			 	 <p>Подклассы TextConverter специализируются на различных преобразованиях
				и форматах. Например, ASCIIConverter игнорирует запросы на преобразование
				чего бы то ни было, кроме простого текста. С другой стороны, TeXConverter будет
				реализовывать все запросы для получения представления в формате редактора TJX,
				собирая по ходу необходимую информацию о стилях. A Text Widget Converter
				станет строить сложный объект пользовательского интерфейса, который позво
				лит пользователю просматривать и редактировать текст.</p>
				<img src="../img/book/103.jpg" alt="#"/>
				 <p>Класс каждого конвертора принимает механизм создания и сборки сложного
				объекта и скрывает его за абстрактным интерфейсом. Конвертор отделен от загруз
				чика, который отвечает за синтаксический разбор RTF-документа.</p>
				 <p>В паттерне строитель абстрагированы все эти отношения. В нем любой класс
				конвертора называется строителем, а загрузчик - распорядителем. В применении
				к рассмотренному примеру строитель отделяет алгоритм интерпретации форма
				та текста (то есть анализатор RTF-документов) от того, как создается и представля
				ется документ в преобразованном формате. Это позволяет повторно использовать
				алгоритм разбора, реализованный в RTFReader, для создания разных текстовых
				представлений RTF-документов; достаточно передать в RTFReader различные под
				классы класса Text Converter.</p>
				<p><b><i>Применимость</p></b></i>
				Используйте паттерн строитель, когда:
				<ul>
				<li>а алгоритм создания сложного объекта не должен зависеть от того, из каких
					частей состоит объект и как они стыкуются между собой;</li>
				<li>а процесс конструирования должен обеспечивать различные представления
					конструируемого объекта.</li>
				</ul>
				<p><b><i>Структура</p></b></i>
				<img src="../img/book/104.jpg" alt="#"/>
				<p><b><i>Участники</p></b></i>
				<ul>
					<li>a <b>Builder</b> (TextConverter) - строитель:
						<ul>
						<li>
						- задает абстрактный интерфейс для создания частей объекта Product;
						</li>
						</ul>
					</li>
					<li>a <b>ConcreteBuilder</b> (ASCIIConverter,TeXConverter,TextWidgetConverter)-
					конкретный строитель:
						<ul>
						<li>
						- конструирует и собирает вместе части продукта посредством реализации
					интерфейса Builder;</li>
						<li>
						- определяет создаваемое представление и следит за ним;</li>
						<li>
						- предоставляет интерфейс для доступа к продукту (например, GetASCI IText,
					GetTextWidget);</li>
						</ul>
					</li>
					<li>a <b>Director</b> (RTFReader) - распорядитель:
						<ul>
						<li>
						- конструирует объект, пользуясь интерфейсом Builder;
						</li>
						</ul>
					</li>	
					<li>a <b>Product</b> (ASCIIText, TeXText, TextWidget) - продукт:
						<ul>
						<li>
						- представляет сложный конструируемый объект. ConcreteBuilder
						строит внутреннее представление продукта и определяет процесс его
						сборки;
						</li>
						<li>
						- включает классы, которые определяют составные части, в том числе ин
						терфейсы для сборки конечного результата из частей.
						</li>
						</ul>
					</li>
				</ul>
				<p><b><i>Отношения</p></b></i>
				<ul>

				<li>а клиент создает объект-распорядитель Director и конфигурирует его нуж
						ным объектом-строителем Builder;</li>
				<li>а распорядитель уведомляет строителя о том, что нужно построить очеред
						ную часть продукта;</li>
				<li>а строитель обрабатывает запросы распорядителя и добавляет новые части
						к продукту;</li>
				<li>а клиент забирает продукт у строителя.</li>
				</ul>
				 <p>Следующая диаграмма взаимодействий иллюстрирует взаимоотношения стро
				ителя и распорядителя с клиентом.</p>
				<img src="../img/book/105.jpg" alt="#"/>
				<p><b><i>Результаты</p></b></i>
				<p>Плюсы и минусы паттерна строитель и его применения:</p>
				<ul>
				<li>а <i>позволяет изменять внутреннее представление продукта</i>. Объект Builder
						предоставляет распорядителю абстрактный интерфейс для конструирова
						ния продукта, за которым он может скрыть представление и внутреннюю
						структуру продукта, а также процесс его сборки. Поскольку продукт констру
						ируется через абстрактный интерфейс, то для изменения внутреннего пред
						ставления достаточно всего лишь определить новый вид строителя;</li>
				<li>а <i>изолирует код, реализующий конструирование и представление</i>. Паттерн
						строитель улучшает модульность, инкапсулируя способ конструирования
						и представления сложного объекта. Клиентам ничего не надо знать о клас
						сах, определяющих внутреннюю структуру продукта, они отсутствуют в ин
						терфейсе строителя.
						Каждый конкретный строитель ConcreteBuilder содержит весь код, не
						обходимый для создания и сборки конкретного вида продукта. Код пишет
						ся только один раз, после чего разные распорядители могут использовать
						его повторно для построения вариантов продукта из одних и тех же частей.
						В примере с RTF-документом мы могли бы определить загрузчик для фор
						мата, отличного от RTF, скажем, SGMLReader, и воспользоваться теми же
						самыми классами TextConverters для генерирования представлений
						SGML-документов в виде ASCII-текста, ТеХ-текста или текстового виджета;</li>
				<li>а <i>дает более тонкий контроль над процессом конструирования</i>. В отличие от
						порождающих паттернов, которые сразу конструируют весь объект цели
						ком, строитель делает это шаг за шагом под управлением распорядителя.
						И лишь когда продукт завершен, распорядитель забирает его у строителя.
						Поэтому интерфейс строителя в большей степени отражает процесс кон
						струирования продукта, нежели другие порождающие паттерны. Это позво
						ляет обеспечить более тонкий контроль над процессом конструирования,
						а значит, и над внутренней структурой готового продукта.</li>
				</ul>
				<p><b><i>Реализация</p></b></i>
				 <p>Обычно существует абстрактный класс Builder, в котором определены опера
				ции для каждого компонента, который распорядитель может «попросить» создать.
				По умолчанию эти операции ничего не делают. Но в классе конкретного строите
				ля ConcreteBuilder они замещены для тех компонентов, в создании которых
				он принимает участие.</p>
				 <p>Вот еще некоторые достойные внимания вопросы реализации:</p>
				<ul>
				<li>а <i>интерфейс сборки и конструирования</i>. Строители конструируют свои про
						дукты шаг за шагом. Поэтому интерфейс класса Builder должен быть до
						статочно общим, чтобы обеспечить конструирование при любом виде кон
						кретного строителя.
						Ключевой вопрос проектирования связан с выбором модели процесса кон
						струирования и сборки. Обычно бывает достаточно модели, в которой ре
						зультаты выполнения запросов на конструирование просто добавляются
						к продукту. В примере с RTF-документами строитель преобразует и добав
						ляет очередную лексему к уже конвертированному тексту.
						Но иногда может потребоваться доступ к частям сконструированного к дан
						ному моменту продукта. В примере с лабиринтом, который будет описан
						в разделе «Пример кода», интерфейс класса MazeBui Ider позволяет добав
						лять дверь между уже существующими комнатами. Другим примером явля
						ются древовидные структуры, скажем, деревья синтаксического разбора, ко
						торые строятся снизу вверх. В этом случае строитель должен был бы вернуть
						узлы-потомки распорядителю, который затем передал бы их назад строите
						лю, чтобы тот мог построить родительские узлы.</li>
				<li>Q <i>почему нет абстрактного класса для продуктов</i>. В типичном случае продук
						ты, изготавливаемые различными строителями, имеют настолько разные
						представления, что изобретение для них общего родительского класса</li>
						ничего не дает. В примере с RTF-документами трудно представить себе об
						щий интерфейс у объектов ASCIIText и TextWidget, да он и не нужен.
						Поскольку клиент обычно конфигурирует распорядителя подходящим кон
						кретным строителем, то, надо полагать, ему известно, какой именно под
						класс класса Builder используется и как нужно обращаться с произведен
						ными продуктами;
				<li>а <i>пустые методы класса Builder no умолчанию</i>. В C++ методы строителя на
						меренно не объявлены чисто виртуальными функциями-членами. Вместо
						этого они определены как пустые функции, что позволяет подклассу заме
						щать только те операции, в которых он заинтересован.</li>
				</ul>
				<p><b><i>Пример кода</i></b></p>
				 <p>Определим вариант функции-члена CreateMaze, которая принимает в каче
				стве аргумента строитель, принадлежащий классу MazeBuilder.
				Класс MazeBuilder определяет следующий интерфейс для построения ла
				биринтов:</p>
				<pre>
				class MazeBuilder {
				public:
					virtual void BuildMaze() { }
					virtual void BuildRoom(int room) { }
					virtual void BuildDoor(int roomFrom, int roomTo) { }

					virtual Maze* GetMaze() { return 0; }
				protected:
					MazeBuilder();
				};
				</pre>
				 <p>Этот интерфейс позволяет создавать три вещи: лабиринт, комнату с конкрет
				ным номером, двери между пронумерованными комнатами. Операция GetMaze
				возвращает лабиринт клиенту. В подклассах MazeBui Ider данная операция пере
				определяется для возврата реально созданного лабиринта.</p>
				 <p>Все операции построения лабиринта в классе MazeBuilder по умолчанию
				ничего не делают. Но они не объявлены исключительно виртуальными, чтобы
				в производных классах можно было замещать лишь часть методов.</b>
				 <p>Имея интерфейс MazeBuilder, можно изменить функцию-член CreateMaze,
				чтобы она принимала строитель в качестве параметра:</p>
				<pre>
				Maze* MazeGame::CreateMaze (MazeBuilder& builder) {
					builder.BuildMaze();

					builder.BuiIdRoom(l);
					builder.BuiIdRoom(2) ;
					builder.BuildDoor(1, 2);

					return builder.GetMaze();
				}
				</pre>
				 <p>Сравните эту версию CreateMaze с первоначальной. Обратите внимание, как
				строитель скрывает внутреннее представление лабиринта, то есть классы комнат,
				дверей и стен, и как эти части собираются вместе для завершения построения ла
				биринта. Кто-то, может, и догадается, что для представления комнат и дверей есть
				особые классы, но относительно стен нет даже намека. За счет этого становится
				проще модифицировать способ представления лабиринта, поскольку ни одного
				из клиентов MazeBuilder изменять не надо.</p>
				 <p>Как и другие порождающие паттерны, строитель инкапсулирует способ со
				здания объектов; в данном случае с помощью интерфейса, определенного классом
				MazeBuilder. Это означает, что MazeBuilder можно повторно использовать для
				построения лабиринтов разных видов. В качестве примера приведем функцию
				GreateComplexMaze:</p>
				<pre>
				Maze* MazeGame::CreateComplexMaze (MazeBuilder& builder) {
					builder.BuildRoom(l);

					builder.BuildRoom(lOOl);

					return builder.GetMazeO ;
				</pre>
				 <p>Обратите внимание, что MazeBuilder не создает лабиринты самостоятель
				но, его основная цель - просто определить интерфейс для создания лабиринтов.
				Пустые реализации в этом интерфейсе определены только для удобства. Реаль
				ную работу выполняют подклассы MazeBuilder.</p>
				 <p>Подкласс StandardMazeBuilder содержит реализацию построения простых
				лабиринтов. Чтобы следить за процессом создания, используется переменная
				_currentMaze:</p>
				<pre>
				class StandardMazeBuilder : public MazeBuilder {
				public:
					StandardMazeBuilder();

					virtual void BuildMazeO;
					virtual void BuildRoom(int);
					virtual void BuildDoor(int, int);

					virtual Maze* GetMazef);
				private:
					Direction CommonWall(Room*, Room*);
					Maze* _currentMaze;
				};
				</pre>
				 <p>CommonWall (общая стена) - это вспомогательная операция, которая опреде
				ляет направление общей для двух комнат стены.</p>
				 <p>Конструктор StandardMazeBuilder просто инициализирует „currentMaze:</p>
				 <pre>
				StandardMazeBuilder::StandardMazeBuilder () {
					_currentMaze = 0;
				}
				</pre>
				 <p>BuildMaze инстанцирует объект класса Maze, который будет собираться дру
				гими операциями и, в конце концов, возвратится клиенту (с помощью GetMaze):</p>
				void StandardMazeBuilder: : BuildMaze () {
					_currentMaze = new Maze;
				}
				Maze* StandardMazeBuilder::GetMaze () {
					return _currentMaze;
				}
				 <p><b>Операция BuildRoom создает комнату и строит вокруг нее стены:</b></p>
				<pre>
				void StandardMazeBuilder::BuildRoom (int n) {
					if (!_currentMaze->RoomNo(n)) {
						Room* room = new Room(n);
						_currentMaze->AddRoom(room);

						room->SetSide(North, new Wall);
						room->SetSide(South, new Wall);
						room->SetSide(East, new Wall);
						room->SetSide(West, new Wall);
					}
				}
				</pre>
				 <p>Чтобы построить дверь между двумя комнатами, StandardMazeBuilder на
				ходит обе комнаты в лабиринте и их общую стену:</p>
				<pre>
				void StandardMazeBuilder : rBuildDoor (int nl , int n2 ) {
					Room* rl = _currentMaze->RoomNo (nl) ;
					Room* r2 = _currentMaze->RoomNo (n2) ;
					Door* d = new Door(rl, r2) ;

					rl->SetSide(CommonWall(rl,r2) , d) ;
					r2->SetSide(CommonWall(r2,rl) , d) ;
				}
				</pre>
				 <p>Теперь для создания лабиринта клиенты могут использовать Great eMaze в со
				четании с StandardMazeBuilder:</p>
				<pre>
				Maze* maze;
				MazeGame game;
				StandardMazeBuilder builder;

				game. CreateMaze (builder) ;
				maze = builder. GetMaze ( );
				</pre>
				 <p>Мы могли бы поместить все операции класса StandardMazeBuilder в класс
				Maze и позволить каждому лабиринту строить самого себя. Но чем меньше класс
				Maze, тем проще он для понимания и модификации, a StandardMazeBuilder
				легко отделяется от Maze. Еще важнее то, что разделение этих двух классов поз
				воляет иметь множество разновидностей класса MazeBuilder, в каждом из кото
				рых есть собственные классы для комнат, дверей и стен.</p>
				 <p>Необычным вариантом MazeBuiIder является класс Count ingMazeBuiIder.
				Этот строитель вообще не создает никакого лабиринта, он лишь подсчитывает
				число компонентов разного вида, которые могли бы быть созданы:</p>
				<pre>
				class CountingMazeBuilder : public MazeBuilder {
				public:
					CountingMazeBuilderO ;

					virtual void BuildMazeO;
					virtual void BuildRoom(int) ;
					virtual void BuildDoor (int, int);
					virtual void AddWall(int, Direction);

					void GetCounts (int&, int&) const;
				private:
					int _doors,-
					int _rooms;
				};
				</pre>
				 <p>Конструктор инициализирует счетчики, а замещенные операции класса
				MazeBuilder увеличивают их:</p>
				CountingMazeBuilder: : CountingMazeBuilder () {
					_rooms = _doors = 0;
				}
				void CountingMazeBuilder::BuildRoom (int) {
					_rooms++;
				}
				void CountingMazeBuilder: .-BuildDoor (int, int) {
					_doors++;
				}
				void CountingMazeBuilder::GetCounts (
					int& rooms, int& doors
				) const {
					rooms = _rooms;
					doors = _doors;
				}
				<p><b>Вот как клиент мог бы использовать класс CountingMazeBuilder:</b></p>
				<pre>
				int rooms, doors;
				MazeGame game;
				CountingMazeBuilder builder;

				game.CreateMaze(builder);
				buiIder.GetCount s(rooms, doors);

				cout « "В лабиринте есть "
				
				« rooms « " комнат и "
				« doors « " дверей" « endl;
				</pre>
				<p><b><i>Известные применения</i></b></p>
				 <p>Приложение для конвертирования из формата RTF взято из библиотеки
				ЕТ++ [WGM88]. В ней используется строитель для обработки текста, хранящего
				ся в таком формате.</p>
				 <p>Паттерн строитель широко применяется в языке Smalltalk-80 [РагЭО]:</p>
				 <ul>
				<li>а класс Parser в подсистеме компиляции - это распорядитель, которому
						в качестве аргумента передается объект ProgramNodeBuilder. Объект
						класса Parser извещает объект ProgramNodeBuilder после распознава
						ния каждой ситаксической конструкции. После завершения синтаксическо
						го разбора Parser обращается к строителю за созданным деревом разбора
						и возвращает его клиенту;</li>
				<li>a Class Builder- это строитель, которым пользуются все классы для созда
						ния своих подклассов. В данном случае этот класс выступает одновременно
						в качестве распорядителя и продукта;</li>
				<li>a ByteCodeStream- это строитель, который создает откомпилированный
						метод в виде массива байтов. ByteCodeStream является примером нестан
						дартного применения паттерна строитель, поскольку сложный объект
						представляется как массив байтов, а не как обычный объект Smalltalk. Но
						интерфейс к ByteCodeStream типичен для строителя, и этот класс легко
						можно было бы заменить другим, который представляет программу в виде
						составного объекта.</li>
				 </ul>		
				<p><b><i>Родственные паттерны</i></b></p>
				 <p>Абстрактная фабрика похожа на строитель в том смысле, что может кон
				струировать сложные объекты. Основное различие между ними в том, что строи
				тель делает акцент на пошаговом конструировании объекта, а абстрактная фаб
				рика - на создании семейств объектов (простых или сложных). Строитель
				возвращает продукт на последнем шаге, тогда как с точки зрения абстрактной
				фабрики продукт возвращается немедленно.</p>
				 <p>Паттерн компоновщик - это то, что часто создает строитель.</p>

		</div>
	</body>
</html>